## 上手 simulink 仿真  
所需要搭建的函数  
![](png/Pasted%20image%2020250921150949.png)  
!!! tip "流程"  
    1. 点击库浏览器  
        1. 我们现在使用的是 simulink 模块的，最主要使用的是上面的常用模块（commonly）  
    2. 第一个函数，一个函数的微分等于另一个函数  
        1. 我们使用的是积分器（Integrator）  
        2. 将积分器拖出来之后，将两侧的箭头延长，双击一下箭头，输入值为 $x_1,x_2$  
        3. 积分的结果：![](png/Pasted%20image%2020250921151524.png)  
        4. 现在我们使用的是**块直接搭建**，这是比较麻烦的，进阶的话需要使用 matlab 的 s 函数  
    3. 第二个**函数**  
        1. 我们使用的是 User-Defined Function 里面的 Fcn 函数  
        2. 右边有着 4 个参数，使用常用种的 **Mux 函数**，将函数指向上面的 Fcn 函数吗，设置函数的值为 **4 个参数**，左侧的箭头数目会变为 4  
            1. 常数使用 **constant 函数**，函数中的 m 参数  
            2. k 使用 source 中的**阶梯模块**，命名为 k, 设置输出的向量为 8（现在相当于一个**常数**），采样的时间为 25  
            3. 设置上面的停止的时间为 50（仿真的时间）  
        3. 将上面的 x 1 的箭头**指向**其中的一个箭头（Mux 中的）  
        4. 还有 u 函数，同样复制一个 Fcn 函数，使用**ctrl+R**进行函数的翻转  
        5. 加上所有的参数之后，进行双击，**表达式的填写**  
            1.  常规表达式块。使用 "u" 作为输入变量名称  
            2. $-u(3)/u(4)*u(1)^3+1/u(4)*u(2)$ 从上到下分别是 1,2,3,4 的编号  
            3. 现在这个函数就写好了，但是还是得积分  
        6. 复制一个积分器（可以使用 ctrl+c，也可以按住 ctrl 再拖动），将其链接到第一个函数的左边，就形成闭环了  
        7. 结果：![](png/Pasted%20image%2020250921154400.png)  
    4. 第三个函数  
        1. 使用常用中的 **out**, 构件三个，因为 xd 出现了三种（原函数，导函数，再导函数）  
        2. 选中构件的三个，**右键构建子函数**，之后将**原来的删除**，双击可以打开我们构建的子系统  
        3. 使用常用种的**相加（sum）**, 将 x 1 的两个指向，因为实际上是建好，所以双击改成 `|+-` 就好了（|代表挡板，相当于一个占位符）  
        4. ![](png/Pasted%20image%2020250921155237.png)  
    5. e 2 复杂，还是使用函数模块（**鼠标滚轮放大，按住拖动**）  
        1. 还是使用 **Fun 与 Mux 函数**，4 个参数  
        2. 用到什么，连起来就可以  
        3. $u(3)+u(1)*u(2)-u(4)$ 函数  
        4. 想要出现分支时可以**按住右键或者 ctrl＋左键**  
    6. 第5 个函数  
        1. 照常，使用积分器、Fun 和 Mux  
        2. $u(1)/u(2)*u(3)^3$  
    7. 最后 u 的搭建，大工程  
        1. 必须用到函数和 Mux  
        2. `u(1)*u(2)+u(1)*u(3)+u(1)*u(4)*(u(5)-u(6))+u(7)*u(8)^3+u(1)*u(9)*u(10)`  
    8. 搭建：![](png/Pasted%20image%2020250921161111.png)  
    9. 预设的子系统：  
        1. 我们希望预设一个**正弦函数**（$Asin(\omega t+\phi)+B$）  
            1. 为什么要自己搭建呢，在 source 中是有 sine wave 的**正弦波**的，还有**导数的函数**: Derivative，**示波器**：Scope（常用中的）  
            2. 双击示波器，在文件中设置为 3 个输入的口（输入 sin，其导函数，再导函数）  
            3. 双击示波器点击里面的运行（视图中点击图例）  
            4. ![](png/Pasted%20image%2020250921162253.png)  
            5. 发现在开始的时候会有时间的偏差，所以不适用这种方法获得正弦及其导函数  
        2. 自己搭建  
            1. 有四个参数（简化掉 phi）  
            2. t（运行的时间参数）在 source 中的 clock  
            3. B 在 source 中给一个重复的阶梯类型  
            4. 其他两个使用常用种的常值（修改 A 为 5，周期为 20）  
            5. `u(1)+u(2)*sin(2*pi/u(3)*u(4)`  
            6. `2*pi/u(3)*u(2)*cos(2*pi/u(3)*u(4)`  
            7. `-2*pi/u(3)*2*pi/u(3)*u(2)*sin(2*pi/u(3)*u(4)`  
            8. 这就是我们搭建的子系统：  
            9. ![](png/Pasted%20image%2020250921163603.png)  
    10. 看一下最后的结果：  
        1. 示波器，两个口，将 x_1 和 x_{1 d}显示  
        2. 在子系统中设置 B, 先设置为 0  
        3. ![](png/Pasted%20image%2020250921165136.png)  
        4. 最后的结果：跟踪的结果很好（使得 x 1 跟踪 x 1 d 正弦函数）  

---
我们此处的 k 如果是已知的话，最后的函数中的 k_{hat}就应该改成 k  

- 使用示波器比较 k 和 k_hat: (我们现在 k 的值为 8，k_hat 是跟踪 k 的值的)
- ![](png/Pasted%20image%2020250921170207.png)
- 现在改变 k 的值，[8 10]，先是8 后面是 10
    - 也是可以跟踪的
- 现在更改 B 的值![](png/Pasted%20image%2020250921170510.png)
- ![](png/Pasted%20image%2020250921170554.png)
- 输出的值，还是可以跟踪的
